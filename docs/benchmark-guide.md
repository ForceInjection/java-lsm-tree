# BenchmarkRunner 基准测试工具使用指南

## 1. 概述

BenchmarkRunner 是一个专门为 LSM Tree 数据库设计的高性能基准测试工具，基于 `com.brianxiadong.lsmtree.BenchmarkRunner` 类实现。该工具提供了全面的性能测试场景，支持多维度的性能指标采集和分析，帮助开发者深入评估 LSM Tree 数据库在不同工作负载下的性能表现。

**核心特性**：

- **多场景测试支持** - 涵盖顺序/随机读写、混合操作、并发测试等典型场景
- **精确性能度量** - 提供吞吐量、延迟分布、内存使用等详细统计指标
- **LSM Tree 专项监控** - 深度集成 MemTable、SSTable、Bloom Filter 等组件状态监控
- **灵活参数配置** - 支持操作数量、键值大小、并发度等多维度参数调优
- **实时状态报告** - 提供测试过程中的实时性能监控和资源使用统计

---

## 2. 功能特性

### 2.1 基准测试场景

BenchmarkRunner 提供了全面的 LSM Tree 性能测试场景，涵盖数据库操作的各个维度：

#### 2.1.1 写入性能测试

- **顺序写入基准** - 测试连续键值对的写入吞吐量和延迟特性
- **随机写入基准** - 评估随机访问模式下的写入性能表现
- **批量写入基准** - 测试大批量数据写入的性能优化效果

#### 2.1.2 读取性能测试

- **顺序读取基准** - 测试范围查询和顺序扫描的性能特征
- **随机读取基准** - 评估点查询在不同数据分布下的性能表现
- **缓存命中基准** - 测试 MemTable 和 Bloom Filter 的过滤效果

#### 2.1.3 混合操作测试

- **读写混合基准** - 模拟真实工作负载的读写比例和性能特征
- **删除操作基准** - 测试删除标记和墓碑记录的性能影响
- **并发访问基准** - 评估多线程并发场景下的性能和一致性

#### 2.1.4 LSM Tree 专项测试

- **MemTable 刷新基准** - 测试内存表刷新到 SSTable 的性能开销
- **压缩操作基准** - 评估不同层级压缩策略的性能影响
- **Bloom Filter 基准** - 测试布隆过滤器的查询加速效果

### 2.2 性能监控与统计

#### 2.2.1 核心性能指标

- **吞吐量统计** - ops/sec、总操作数、错误率等关键指标
- **延迟分布分析** - 平均延迟、P50/P95/P99 分位数、最大延迟
- **内存使用监控** - 初始/峰值/最终内存使用量和增长趋势

#### 2.2.2 LSM Tree 状态监控

- **MemTable 状态** - 当前大小、刷新频率、写入缓冲区利用率
- **SSTable 层级统计** - 各层文件数量、大小分布、压缩状态
- **Bloom Filter 统计** - 命中率、误判率、内存占用情况

#### 2.2.3 实时监控能力

- **测试进度跟踪** - 实时显示测试完成进度和预估剩余时间
- **资源使用监控** - CPU、内存、磁盘 I/O 等系统资源使用情况
- **异常检测报告** - 自动识别性能异常和潜在问题

## 3. 安装和编译

```bash
# 使用项目提供的构建脚本
./build.sh
```

---

## 4. 使用方法

### 4.1 基本用法

```bash
# 使用默认参数运行所有基准测试
java -cp target/java-lsm-tree-1.0.0.jar com.brianxiadong.lsmtree.BenchmarkRunner

# 使用自定义参数
java -cp target/java-lsm-tree-1.0.0.jar com.brianxiadong.lsmtree.BenchmarkRunner \
  --operations 50000 \
  --threads 4 \
  --key-size 32 \
  --value-size 200 \
  --data-dir ./my_benchmark_data
```

### 4.2 命令行参数

| 参数           | 描述               | 默认值             | 示例                     |
| -------------- | ------------------ | ------------------ | ------------------------ |
| `--operations` | 每个测试的操作数量 | 100000             | `--operations 50000`     |
| `--key-size`   | 键的大小（字节）   | 16                 | `--key-size 32`          |
| `--value-size` | 值的大小（字节）   | 100                | `--value-size 200`       |
| `--data-dir`   | 数据存储目录       | `./benchmark_data` | `--data-dir ./test_data` |
| `--seed`       | 随机数种子         | 当前时间戳         | `--seed 12345`           |
| `--threads`    | 并发测试的线程数   | CPU 核心数         | `--threads 4`            |
| `--help`, `-h` | 显示帮助信息       | -                  | `--help`                 |

### 4.3 使用示例

#### 4.3.1 快速性能测试

```bash
# 运行 10,000 次操作的快速测试
java -cp target/java-lsm-tree-1.0.0.jar com.brianxiadong.lsmtree.BenchmarkRunner \
  --operations 10000
```

#### 4.3.2 高负载测试

```bash
# 运行 1,000,000 次操作的高负载测试
java -cp target/java-lsm-tree-1.0.0.jar com.brianxiadong.lsmtree.BenchmarkRunner \
  --operations 1000000 \
  --threads 8
```

#### 4.3.3 大键值测试

```bash
# 测试大键值对的性能
java -cp target/java-lsm-tree-1.0.0.jar com.brianxiadong.lsmtree.BenchmarkRunner \
  --operations 50000 \
  --key-size 64 \
  --value-size 1024
```

### 4.4 输出格式说明

#### 4.4.1 控制台输出格式

基准测试结果以结构化格式输出，包含以下关键信息：

```bash
=== 顺序写入 详细统计 ===
总操作数: 100000
错误数: 0 (0.00%)
总耗时: 2.45 秒
吞吐量: 40816.33 ops/sec
平均延迟: 0.02 ms
P50 延迟: 0.01 ms
P95 延迟: 0.05 ms
P99 延迟: 0.12 ms
最大延迟: 15.23 ms

=== 内存使用统计 ===
初始内存: 128.5 MB
峰值内存: 256.8 MB
最终内存: 189.2 MB
内存增长: 60.7 MB

=== LSM Tree 状态 ===
MemTable 大小: 64.0 MB
Level 0 SSTable: 12 个文件
Level 1 SSTable: 3 个文件
Bloom Filter 命中率: 95.2%
```

#### 4.4.2 性能指标解读

- **吞吐量 (ops/sec)**: 每秒完成的操作数，越高越好
- **延迟分布**: P50/P95/P99 分位数反映延迟分布特征
- **内存增长**: 测试过程中的内存使用变化
- **LSM Tree 状态**: 内部组件的实时状态信息

---

## 5. 应用场景

### 5.1 性能基准建立

#### 5.1.1 系统性能评估

- **新系统部署验证** - 验证 LSM Tree 实现在目标环境下的性能表现
- **硬件配置优化** - 评估不同硬件配置对数据库性能的影响
- **版本升级对比** - 对比不同版本间的性能差异和改进效果

#### 5.1.2 工作负载建模

- **真实场景模拟** - 根据实际业务特征配置测试参数
- **峰值负载测试** - 评估系统在高并发场景下的稳定性
- **长期运行测试** - 验证系统在长时间运行下的性能稳定性

### 5.2 性能调优指导

#### 5.2.1 参数优化验证

- **MemTable 大小调优** - 测试不同内存表大小对性能的影响
- **压缩策略优化** - 评估不同压缩策略的性能权衡
- **Bloom Filter 配置** - 优化布隆过滤器参数以提升查询性能

#### 5.2.2 瓶颈识别分析

- **I/O 瓶颈检测** - 识别磁盘读写操作的性能瓶颈
- **内存使用分析** - 分析内存分配和回收的性能影响
- **并发冲突诊断** - 检测多线程访问中的性能热点

---

## 6. 使用注意事项

### 6.1 常见问题与解决方案

#### 6.1.1 内存相关问题

- **内存不足错误**: 适当增加 JVM 堆内存大小 (`-Xmx` 参数)
- **内存泄漏检测**: 关注测试过程中的内存增长趋势
- **GC 频繁触发**: 监控垃圾回收对测试结果的影响

#### 6.1.2 文件系统问题

- **数据目录权限**: 确保指定的数据目录具有读写权限
- **磁盘空间不足**: 预估测试数据大小，确保有足够的存储空间
- **文件句柄限制**: 在高并发测试时注意系统文件句柄限制

#### 6.1.3 参数配置问题

- **线程数过多**: 避免设置过多线程导致上下文切换开销
- **操作数量设置**: 根据测试目标合理设置操作数量
- **键值大小配置**: 考虑内存和磁盘容量限制

### 6.2 测试参数建议

#### 6.2.1 线程数配置

- **CPU 密集型场景**: 设置为 CPU 核心数
- **I/O 密集型场景**: 可设置为 CPU 核心数的 1.5-2 倍
- **混合场景**: 根据实际测试结果调整

#### 6.2.2 操作数量配置

- **快速验证**: 10,000 - 50,000 次操作
- **标准测试**: 100,000 - 500,000 次操作
- **压力测试**: 1,000,000+ 次操作

#### 6.2.3 键值大小配置

- **小数据场景**: key=16B, value=100B
- **中等数据场景**: key=32B, value=512B
- **大数据场景**: key=64B, value=2KB+

### 6.3 测试套件集成

#### 6.3.1 使用测试套件运行

```bash
# 运行完整的性能测试套件
./test-suite/test-suite.sh performance

# 查看测试结果
ls -la test-suite/results/sessions/*/performance/
```

#### 6.3.2 调试模式

```bash
# 启用详细日志输出
java -Djava.util.logging.level=FINE \
  -cp target/java-lsm-tree-1.0.0.jar com.brianxiadong.lsmtree.BenchmarkRunner
```

### 6.4 结果分析建议

#### 6.4.1 测试稳定性

- **多次运行**: 进行多轮测试以获得稳定的性能数据
- **环境一致性**: 确保测试环境的一致性和可重复性
- **基准对比**: 建立性能基准线，便于版本间对比

#### 6.4.2 指标关注重点

- **延迟分布**: 重点关注 P95、P99 延迟而非仅平均值
- **吞吐量趋势**: 观察不同负载下的吞吐量变化
- **资源使用**: 监控 CPU、内存、磁盘 I/O 使用情况

---

## 7. 相关文档

- [LSM Tree 深度解析](./lsm-tree-deep-dive.md)
- [性能分析指南](./performance-analysis-guide.md)
- [源码分析文档](./soucrce-code-analysis.md)
- [测试套件使用说明](../test-suite/README.md)
