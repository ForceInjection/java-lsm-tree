# 第1章：LSM Tree 概述

## 什么是LSM Tree？

**Log-Structured Merge Tree (LSM Tree)** 是一种专为写密集型工作负载优化的数据结构。它被广泛应用于现代数据库系统中，如LevelDB、RocksDB、Cassandra、HBase等。

### 核心设计思想

LSM Tree的核心思想是：
- **将随机写入转换为顺序写入**
- **将写入操作与读取操作分离优化**
- **通过多层存储结构平衡内存和磁盘的使用**

## LSM Tree vs 传统B+树

| 特征 | B+树 | LSM Tree |
|------|------|----------|
| 写入性能 | O(log N) 随机写 | O(log M) 顺序写 (M << N) |
| 读取性能 | O(log N) | O(log N + K) |
| 空间放大 | 低 | 中等 |
| 写放大 | 高 | 低 |
| 适用场景 | 读多写少 | 写多读少 |

## LSM Tree 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                        LSM Tree 架构                         │
├─────────────────────────────────────────────────────────────┤
│  写入路径: Client → WAL → MemTable → (满) → SSTable         │
│  读取路径: Client → MemTable → Immutable → SSTables        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐    ┌─────────────────────────────────────┐│
│  │  Write-Ahead │    │           内存层                    ││
│  │     Log      │    │  ┌─────────────┐ ┌─────────────────┐││
│  │   (WAL)      │───▶│  │Active       │ │Immutable        │││
│  │              │    │  │MemTable     │ │MemTables        │││
│  └──────────────┘    │  └─────────────┘ └─────────────────┘││
│                      └─────────────────────────────────────┘│
│                                    │                        │
│                                    ▼                        │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                      磁盘层                              ││
│  │  Level 0: [SST] [SST] [SST] [SST]                      ││
│  │  Level 1: [SST] [SST] [SST] [SST] [SST] [SST]          ││
│  │  Level 2: [SST] [SST] [SST] ... (更多文件)             ││
│  │  Level N: [SST] [SST] [SST] ... (最大层)               ││
│  └─────────────────────────────────────────────────────────┘│
├─────────────────────────────────────────────────────────────┤
│  后台压缩: 定期合并SSTable文件，清理重复/删除的数据          │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件详解

### 1. MemTable (内存表)
- **作用**: 内存中的有序数据结构，接收所有写入操作
- **实现**: 使用跳表 (ConcurrentSkipListMap) 保证有序性和线程安全
- **容量**: 达到阈值时触发刷盘操作

### 2. Immutable MemTable (不可变内存表)
- **作用**: 正在刷盘的MemTable，只读状态
- **目的**: 避免阻塞新的写入操作
- **生命周期**: 刷盘完成后自动删除

### 3. SSTable (Sorted String Table)
- **作用**: 磁盘上的不可变有序文件
- **特点**: 
  - 数据按键有序存储
  - 包含布隆过滤器
  - 支持快速查找

### 4. WAL (Write-Ahead Log)
- **作用**: 写前日志，确保数据持久性
- **格式**: 管道分隔的文本格式
- **恢复**: 系统重启时重放日志恢复数据

### 5. Bloom Filter (布隆过滤器)
- **作用**: 快速判断键是否可能存在
- **优化**: 减少无效的磁盘I/O操作
- **特点**: 无假阴性，有假阳性

### 6. Compaction Strategy (压缩策略)
- **作用**: 后台合并SSTable文件
- **目的**: 
  - 清理过期/删除的数据
  - 控制文件数量
  - 优化查询性能

## 数据流详解

### 写入流程
```
1. 写入WAL日志 (持久化保证)
     ↓
2. 写入Active MemTable
     ↓
3. MemTable满了？
     ├─ 否 → 继续接收写入
     └─ 是 → 转为Immutable MemTable
             ↓
           刷盘到SSTable
             ↓
           删除Immutable MemTable
             ↓
           触发压缩 (如果需要)
```

### 读取流程
```
1. 查询Active MemTable
     ├─ 找到 → 返回结果
     └─ 未找到 ↓

2. 查询Immutable MemTables
     ├─ 找到 → 返回结果  
     └─ 未找到 ↓

3. 按时间倒序查询SSTables
     ├─ 布隆过滤器判断
     │   ├─ 肯定不存在 → 跳过
     │   └─ 可能存在 → 查询文件
     ├─ 找到 → 返回结果
     └─ 所有文件都未找到 → 返回null
```

## 性能特征

### 写入性能优势
- **顺序写入**: WAL和SSTable都是顺序写，充分利用磁盘特性
- **批量刷盘**: MemTable批量写入SSTable，减少I/O次数
- **无锁写入**: 使用并发跳表，减少锁竞争

### 读取性能考虑
- **多层查找**: 需要查询多个数据源
- **布隆过滤器**: 显著减少无效磁盘访问
- **缓存友好**: 热数据通常在MemTable中

### 空间使用
- **写放大**: 压缩过程中的数据重写
- **空间放大**: 删除数据的墓碑标记
- **优化**: 定期压缩清理无效数据

## 实际应用场景

### 适合的场景
- ✅ **写多读少**: 日志系统、监控数据
- ✅ **时序数据**: IoT传感器数据、指标收集
- ✅ **缓存系统**: 高频写入的缓存更新
- ✅ **事件存储**: 审计日志、用户行为跟踪

### 不适合的场景
- ❌ **读多写少**: 传统OLTP应用
- ❌ **复杂查询**: 需要复杂SQL的场景
- ❌ **强一致性**: 需要ACID事务的场景

## 核心优势

1. **高写入吞吐量**: 40万+ ops/sec
2. **低写入延迟**: 平均1.8微秒
3. **良好的扩展性**: 数据量增长对写性能影响小
4. **崩溃恢复**: WAL确保数据不丢失
5. **并发友好**: 支持多线程读写

## 实现挑战

1. **读放大**: 需要查询多个数据源
2. **空间放大**: 压缩前的冗余数据
3. **压缩开销**: 后台压缩消耗CPU/IO
4. **复杂性**: 多组件协调的复杂性

## 下一步学习

现在你已经了解了LSM Tree的整体架构，接下来我们将深入学习各个组件：

1. **KeyValue数据结构** - 理解基础数据格式
2. **MemTable实现** - 深入跳表和并发控制
3. **SSTable格式** - 磁盘存储的设计细节

继续阅读：[第2章：KeyValue 数据结构](02-keyvalue-structure.md)

---

## 思考题

1. 为什么LSM Tree适合写密集型工作负载？
2. 布隆过滤器如何提升读取性能？
3. 压缩策略的作用是什么？

**下一章预告**: 我们将学习LSM Tree的基础数据结构KeyValue，理解时间戳、删除标记等核心概念。 