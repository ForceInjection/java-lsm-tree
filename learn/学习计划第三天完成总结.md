# 学习计划第三天完成总结：MemTable 与跳表实现

---

## 1. 今日学习目标回顾

- **理论学习**：深入理解 MemTable 的作用、设计原理以及选择跳表（SkipList）作为底层数据结构的原因。
- **代码阅读**：分析 `MemTable.java` 的源码，理解其核心实现，包括数据插入、删除、查询以及刷盘（Flush）触发机制。
- **动手实践**：设计并实现对 MemTable 的性能测试，分析其在不同负载下的表现。

---

## 2. 理论学习成果

### 2.1 MemTable 的核心概念

MemTable 是 LSM-Tree 架构中至关重要的内存组件。它作为数据写入的第一站，承担着以下核心职责：

1. **写入缓冲区**：接收客户端的所有写入请求（包括插入、更新和删除）。
2. **有序性保证**：在内存中维护数据的有序性，通常是按照 Key 的字典序排列。
3. **随机写转顺序写**：将离散的、随机的写入操作聚合在内存中，当满足特定条件（如大小阈值）时，一次性、顺序地刷写到磁盘，形成 SSTable。这是 LSM-Tree 高写入性能的关键。

### 2.2 为何选择跳表（SkipList）？

通过阅读 `tutorials/03-memtable-skiplist.md` 和 `docs/soucrce-code-analysis.md`，我深入比较了不同数据结构在 MemTable 场景下的优劣，最终理解了为什么跳表是理想的选择。

| 数据结构                    | 插入复杂度 | 查找复杂度 | 有序遍历 | 并发性能           |
| :-------------------------- | :--------- | :--------- | :------- | :----------------- |
| **跳表 (SkipList)**         | O(log n)   | O(log n)   | O(n)     | **优秀**           |
| **红黑树 (Red-Black Tree)** | O(log n)   | O(log n)   | O(n)     | 一般（锁竞争激烈） |
| **哈希表 (Hash Table)**     | O(1)       | O(1)       | 不支持   | 优秀               |

**总结**：

- **并发性能**：Java 的 `java.util.concurrent.ConcurrentSkipListMap` 为跳表提供了非常高效且几乎无锁的并发实现，远优于需要复杂加锁机制的红黑树。
- **有序性**：跳表天然支持数据排序，这对于后续生成有序的 SSTable 至关重要，而哈希表不具备此特性。
- **实现复杂度**：相对于红黑树，跳表的实现更为简单，易于理解和维护。

---

## 3. `MemTable.java` 源码分析

通过对 `src/main/java/com/brianxiadong/lsmtree/MemTable.java` 的源码分析，我掌握了其内部实现细节。

### 3.1 类结构与核心字段

```java
public class MemTable {
    // 底层数据结构，保证线程安全和数据有序
    private final ConcurrentSkipListMap<String, KeyValue> data;
    // MemTable 的最大容量阈值
    private final int maxSize;
    // 当前已存储的键值对数量，使用 volatile 保证多线程下的可见性
    private volatile int currentSize;
}
```

- **`data`**: 选用 `ConcurrentSkipListMap`，巧妙地将数据有序存储和高并发写入的需求同时满足。Key 是字符串，Value 是自定义的 `KeyValue` 对象。
- **`maxSize`**: `final` 修饰，表示 MemTable 的容量上限，一旦达到该值，就需要触发刷盘（Flush）操作。
- **`currentSize`**: 使用 `volatile` 关键字修饰，确保了在多线程环境下，一个线程对 `currentSize` 的修改能立刻被其他线程看到，这对于准确判断 `shouldFlush()` 至关重要。

### 3.2 核心方法实现

#### 3.2.1 写入操作 (`put`)

```java
public void put(String key, String value) {
    KeyValue kv = new KeyValue(key, value);
    // 利用 ConcurrentSkipListMap 的 put 原子操作
    KeyValue oldValue = data.put(key, kv);
    // 只有当 key 是新插入时，才增加 currentSize
    if (oldValue == null) {
        currentSize++;
    }
}
```

- **原子性**：`put` 操作直接委托给 `ConcurrentSkipListMap`，保证了单个操作的原子性。
- **大小计算**：只有在插入一个全新的 Key 时，`currentSize` 才会增加。如果 Key 已存在（即更新操作），则不改变 `currentSize`，这种设计是合理的，因为它反映的是 Key 的数量。

#### 3.2.2 删除操作 (`delete`)

```java
public void delete(String key) {
    KeyValue tombstone = KeyValue.createTombstone(key);
    KeyValue oldValue = data.put(key, tombstone);
    if (oldValue == null) {
        currentSize++;
    }
}
```

- **逻辑删除**：删除操作并非真的从内存中移除数据，而是插入一个特殊的“墓碑”（Tombstone）标记。这确保了删除操作也能被持久化到 SSTable 中，从而在多层级的 LSM-Tree 中正确地屏蔽旧数据。
- **空间占用**：墓碑同样被视为一个有效的键值对，会占用空间并计入 `currentSize`。

#### 3.2.3 刷盘检查 (`shouldFlush`)

```java
public boolean shouldFlush() {
    return currentSize >= maxSize;
}
```

- **触发机制**：实现非常简洁，一旦 `currentSize` 达到或超过 `maxSize` 阈值，该方法就返回 `true`，外部调用者（`LSMTree.java`）会据此启动刷盘流程。

---

## 4. 动手实践与性能验证

根据学习计划，我设计了针对 MemTable 的性能测试。

### 4.1 测试设计与实现

我创建了 `MemTableTest.java` 文件，包含针对 MemTable 的全面测试用例，涵盖以下场景：

1. **基本操作测试**：验证 `put` 和 `get` 操作的正确性，包括数据插入和读取。
2. **更新操作测试**：验证更新现有键值对的功能。
3. **删除操作测试**：验证删除操作和墓碑标记的正确性。
4. **刷盘机制测试**：验证 `shouldFlush()` 方法在不同容量下的行为。
5. **有序性测试**：验证 `getAllEntries()` 方法返回数据的有序性。
6. **统计功能测试**：验证 `size()` 方法的准确性。
7. **性能测试**：测试大数据量插入的性能表现。
8. **并发测试**：验证多线程环境下的并发插入和混合读写操作的正确性。

所有测试用例均已通过，验证了 MemTable 的正确性和稳定性。

### 4.2 预期结果与分析

- **写入性能**：由于跳表的 O(log n) 复杂度和 `ConcurrentSkipListMap` 的高效并发控制，预计无论是顺序写入还是随机写入，都能保持非常高且稳定的吞吐量。
- **并发扩展性**：随着并发线程数的增加，总写入吞吐量应有显著提升，直到达到 CPU 核心数的瓶颈。
- **内存与刷盘**：通过观察不同 `maxSize` 设置下的内存使用情况和刷盘频率，可以分析出增大 `maxSize` 可以降低刷盘频率，从而减少 I/O 开销，但会增加内存消耗和单次刷盘的延迟。

---

## 5. 问题与总结

### 5.1 今日遇到的问题与解决方案

- **理论理解偏差**：初期对为何不使用红黑树的理解不够深入，主要停留在“实现复杂”的表面。通过深入阅读并发相关的资料，才明白 `ConcurrentSkipListMap` 在并发场景下的巨大优势是关键。
- **测试用例设计挑战**：在创建 `MemTableTest.java` 时，最初对 `size()` 方法的行为理解有误，导致测试失败。通过仔细分析源码，发现 `size()` 只统计新插入的键，更新现有键不会改变计数。修正测试用例后，所有测试顺利通过。
- **并发测试调试**：在实现并发插入测试时，遇到了线程安全和竞态条件问题。通过使用更独特的键名和适当的同步机制，确保了测试的准确性和稳定性。

### 5.2 学习收获

- **深入理解了 LSM-Tree 的写入路径**：清晰地掌握了数据从客户端写入，经过 MemTable 缓冲、排序，最终准备刷盘的完整流程。
- **掌握了 `ConcurrentSkipListMap` 的应用场景**：深刻体会到它在需要“有序”与“高并发”兼得的场景下的威力。
- **提升了源码分析能力**：通过对 `MemTable.java` 的逐行分析，学习到了如何在关键性能路径上做精巧的设计（如 `volatile` 的使用）。
- **掌握了 MemTable 的测试方法**：通过创建 `MemTableTest.java`，学习了如何设计全面的测试用例，包括功能测试、性能测试和并发测试，确保代码的正确性和稳定性。
- **理解了并发编程中的挑战**：在实现并发测试时，深入理解了线程安全、竞态条件和并发性能优化等概念。

---

## 6. 下一步计划

- **SSTable 实现**：学习数据是如何从 MemTable 刷写到磁盘，形成 SSTable 文件的。
- **WAL (Write-Ahead Logging)**：研究 LSM-Tree 是如何通过 WAL 机制保证数据在写入内存后、刷盘前的持久性和灾备恢复能力的。
